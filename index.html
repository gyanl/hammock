<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Lit Map</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <!-- Stylesheets -->
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Instrument+Sans:ital,wght@0,400;1,500&display=swap">

  <!-- Scripts -->

  <script src="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@mapbox/mapbox-sdk/umd/mapbox-sdk.min.js"></script>

</head>

<body>

  <h1 id="introText" class="landing header-fade-in-up">
    Explore the Globe&rsquo;s Literary Legacy <br>One City at a Time
  </h1>

  <div class="center-align">
    <button id="introButton" type="button" class="bottom-center button-tertiary header-fade-in-down">
      Get Started
    </button>
  </div>

  <div id="map"></div>


  <header class="glass">
    <img id="logo" class="logo" src="hammock-white.png">
    <div class="header-links">


      <div class="header-link dropdown" id="continent-dropdown">
        Continents
        <div class="dropdown-content">
          <label><input type="checkbox" id="africa-checkbox"> Africa</label>
          <label><input type="checkbox" id="asia-checkbox"> Asia</label>
          <label><input type="checkbox" id="australia-checkbox"> Australia</label>
          <label><input type="checkbox" id="europe-checkbox"> Europe</label>
          <label><input type="checkbox" id="north-america-checkbox"> North America</label>
          <label><input type="checkbox" id="latin-america-checkbox"> Latin America</label>
        </div>
      </div>

      <div class="header-link dropdown" id="gender-dropdown">
        Gender
        <div class="dropdown-content">
          <label><input type="checkbox" id="male-checkbox"> Male</label>
          <label><input type="checkbox" id="female-checkbox"> Female</label>
          <label><input type="checkbox" id="nonbinary-checkbox"> Non-binary</label>
        </div>
      </div>

      <div class="header-link dropdown" id="awards-dropdown">
        Awards
        <div class="dropdown-content">
          <label><input type="checkbox" id="prix-goncourt-checkbox"> Prix Goncourt</label>
          <label><input type="checkbox" id="international-booker-checkbox"> International Booker Prize</label>
          <label><input type="checkbox" id="neustadt-international-checkbox"> Neustadt International Prize</label>
          <label><input type="checkbox" id="grand-prix-national-checkbox"> Grand Prix National des Lettres</label>
          <label><input type="checkbox" id="camoes-checkbox"> Camoes Prize</label>
          <label><input type="checkbox" id="impac-dublin-checkbox"> IMPAC Dublin Literary Award</label>
          <label><input type="checkbox" id="cervantes-checkbox"> Cervantes Prize</label>
          <label><input type="checkbox" id="prix-medicis-checkbox"> Prix Medicis</label>
          <label><input type="checkbox" id="pulitzer-checkbox"> Pulitzer Prize</label>
          <label><input type="checkbox" id="booker-checkbox"> Booker Prize</label>
          <label><input type="checkbox" id="independent-foreign-checkbox"> Independent Foreign Fiction Prize</label>
          <label><input type="checkbox" id="national-book-checkbox"> National Book Award</label>
          <label><input type="checkbox" id="nobel-checkbox"> Nobel Prize</label>
          <label><input type="checkbox" id="commonwealth-writers-checkbox"> Commonwealth Writers' Prize</label>
          <label><input type="checkbox" id="buchner-checkbox"> Buchner Prize</label>
          <label><input type="checkbox" id="buchner-returned-checkbox"> Buchner Prize (returned)</label>
          <label><input type="checkbox" id="commonwealth-checkbox"> Commonwealth Prize</label>
        </div>
      </div>

      <div class="header-link dropdown" id="language-dropdown">
        Language
        <div class="dropdown-content">
          <label><input type="checkbox" id="afrikaans-checkbox"> Afrikaans</label>
          <label><input type="checkbox" id="albanian-checkbox"> Albanian</label>
          <label><input type="checkbox" id="arabic-checkbox"> Arabic</label>
          <label><input type="checkbox" id="bahasa-checkbox"> Bahasa</label>
          <label><input type="checkbox" id="bengali-checkbox"> Bengali</label>
          <label><input type="checkbox" id="bulgarian-checkbox"> Bulgarian</label>
          <label><input type="checkbox" id="chinese-checkbox"> Chinese</label>
          <label><input type="checkbox" id="croatian-checkbox"> Croatian</label>
          <label><input type="checkbox" id="czech-checkbox"> Czech</label>
          <label><input type="checkbox" id="danish-checkbox"> Danish</label>
          <label><input type="checkbox" id="dutch-checkbox"> Dutch</label>
          <label><input type="checkbox" id="english-checkbox"> English</label>
          <label><input type="checkbox" id="finnish-checkbox"> Finnish</label>
          <label><input type="checkbox" id="french-checkbox"> French</label>
          <label><input type="checkbox" id="georgian-checkbox"> Georgian</label>
          <label><input type="checkbox" id="german-checkbox"> German</label>
          <label><input type="checkbox" id="greek-checkbox"> Greek</label>
          <label><input type="checkbox" id="hebrew-checkbox"> Hebrew</label>
          <label><input type="checkbox" id="hindi-checkbox"> Hindi</label>
          <label><input type="checkbox" id="hungarian-checkbox"> Hungarian</label>
          <label><input type="checkbox" id="icelandic-checkbox"> Icelandic</label>
          <label><input type="checkbox" id="italian-checkbox"> Italian</label>
          <label><input type="checkbox" id="japanese-checkbox"> Japanese</label>
          <label><input type="checkbox" id="kannada-checkbox"> Kannada</label>
          <label><input type="checkbox" id="kiswahili-checkbox"> Kiswahili</label>
          <label><input type="checkbox" id="korean-checkbox"> Korean</label>
          <label><input type="checkbox" id="malayalam-checkbox"> Malayalam</label>
          <label><input type="checkbox" id="norwegian-checkbox"> Norwegian</label>
          <label><input type="checkbox" id="persian-checkbox"> Persian</label>
          <label><input type="checkbox" id="polish-checkbox"> Polish</label>
          <label><input type="checkbox" id="portuguese-checkbox"> Portuguese</label>
          <label><input type="checkbox" id="punjabi-checkbox"> Punjabi</label>
          <label><input type="checkbox" id="romanian-checkbox"> Romanian</label>
          <label><input type="checkbox" id="russian-checkbox"> Russian</label>
          <label><input type="checkbox" id="serbo-croatian-checkbox"> Serbo-Croatian</label>
          <label><input type="checkbox" id="somali-checkbox"> Somali</label>
          <label><input type="checkbox" id="spanish-checkbox"> Spanish</label>
          <label><input type="checkbox" id="swedish-checkbox"> Swedish</label>
          <label><input type="checkbox" id="tamil-checkbox"> Tamil</label>
          <label><input type="checkbox" id="turkish-checkbox"> Turkish</label>
          <label><input type="checkbox" id="ukrainian-checkbox"> Ukrainian</label>
          <label><input type="checkbox" id="urdu-checkbox"> Urdu</label>
          <label><input type="checkbox" id="yiddish-checkbox"> Yiddish</label>
        </div>
      </div>

    </div>

    <div id="search-bar">
      <input id="search-input" type="text" placeholder="Search" enterkeyhint="search">
      <button id="search-clear" type="button" class="search-clear" aria-label="Clear search">
        <img class="icon-x" src="icons/x.svg"></button>
    </div>
    <button class="button-secondary desktop-only" id="btnRandom">
      <span>Feeling lucky</span>
      <div class="icon-circle"><img width="16px" src="icons/shuffle.svg" alt="Shuffle icon"></div>
    </button>

    </div>
  </header>

  <div id="sidebar" class="sidebar glass displaynone fade-in-up">

    <div id="sidebar-search-title-container">
      <span id="sidebar-search-title">
        Result
      </span>
      <button onclick="toggleSidebar()" class="button-primary">
        <img id="chevron" width="16px" src="icons/chevron-up.svg"></button>
    </div>

    <div id="sidebar-search-results" class="sidebar-body"></div>

    <div id="sidebar-author-title" class="sidebar-title fade-in-right" onclick="backToTheResults()">
      <img class="icon-left" src="icons/chevron-left.svg" alt="back"> Back
    </div>

    <div id="sidebar-author-details" class="sidebar-author-details"></div>

  </div>

  <script>

    // Convenient names for the elements
    const logo = document.getElementById('logo');
    const filter = document.getElementById('filter');

    const searchBar = document.querySelector('#search-bar');
    const searchInput = document.getElementById('search-input');
    const clearButton = document.getElementById('search-clear');

    const searchtitle = document.getElementById('sidebar-search-title');
    const searchtitlecontainer = document.getElementById('sidebar-search-title-container');
    const searchresults = document.getElementById('sidebar-search-results');

    const sidebarauthortitle = document.getElementById('sidebar-author-title');
    const sidebarauthordetails = document.getElementById('sidebar-author-details');

    const titlechevron = document.getElementById('chevron');
    const mobileBreakpoint = 768;
    const headerLinks = document.querySelector('.header-links');

    // TODO: Add constants for zoom levels.

    // Function to toggle dropdown content visibility
    function toggleDropdown(dropdownId) {
      // Close all other dropdowns first
      document.querySelectorAll('.dropdown').forEach(dropdown => {
        if (dropdown.id !== dropdownId) {
          dropdown.classList.remove('header-link-active');
          dropdown.querySelector('.dropdown-content').style.display = 'none';
        }
      });

      // Toggle the clicked dropdown
      const dropdown = document.getElementById(dropdownId);
      dropdown.classList.toggle('header-link-active');
      const dropdownContent = dropdown.querySelector('.dropdown-content');
      dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
    }

    // Add click event listeners to all dropdown headers
    document.querySelectorAll('.dropdown').forEach(dropdown => {
      dropdown.addEventListener('click', (event) => {
        // Prevent the click from propagating to the document
        event.stopPropagation();
        toggleDropdown(dropdown.id);
      });
    });

    // Close all dropdowns when clicking outside
    document.addEventListener('click', () => {
      document.querySelectorAll('.dropdown').forEach(dropdown => {
        const content = dropdown.querySelector('.dropdown-content');
        content.style.display = 'none';
        dropdown.classList.remove('header-link-active');
      });
    });

    // Prevent clicks inside dropdown content from closing the dropdown
    document.querySelectorAll('.dropdown-content').forEach(content => {
      content.addEventListener('click', (event) => {
        event.stopPropagation();
      });
    });



    // Fetch the data.geojson file with the authors data
    fetch('data.geojson').then(response => response.json()).then(data => {
      window.data = data;
    });

    // Toggles the sidebar
    function toggleSidebar() {
      searchresults.style.display = searchresults.style.display === 'none' ? 'block' : 'none';
      titlechevron.style.rotate = titlechevron.style.rotate === '180deg' ? '0deg' : '180deg';
    }

    // Sets the sidebar title
    function setSidebarTitle(input) {
      searchtitle.innerHTML = input;
    }

    // Clears the sidebar
    function clearSidebar() {
      searchresults.innerHTML = "";
    }

    // Shows author details in sidebar
    function showAuthorDetails() {
      searchtitlecontainer.style.display = "none";
      searchresults.style.display = "none";

      sidebarauthortitle.style.display = "flex";
      sidebarauthordetails.style.display = "block";
    }

    // Shows results in sidebar
    function showSearchResults() {
      searchtitlecontainer.style.display = "flex";
      searchresults.style.display = "block";

      sidebarauthortitle.style.display = "none";
      sidebarauthordetails.style.display = "none";
    }

    // Shows results in sidebar and zooms out on map
    function backToTheResults() {
      console.log('%c[backToTheResults] Called', 'color: #0af');
      map.easeTo({
        zoom: map.getZoom() - 0.5
      });
      console.log('[backToTheResults] -> showSearchResults() called, map flyTo zoom=3');
      showSearchResults();
    }

    // Update the addAuthorResult function to include more details
    function addAuthorResult(properties, coordinates) {
      const {
        author_name,
        city_birth,
        city_residence,
        country,
        continent,
        year_birth,
        year_death,
        work_1,
        work_2,
        gender,
        language,
        awards,
        bio,
        list_title,
        list_bookname,
        list_copy,
        list_url
      } = properties;

      var authorDetails = `
        <div onclick="setAuthorDetails(${JSON.stringify(properties).replace(/"/g, '&quot;')}, ${coordinates[0]}, ${coordinates[1]})" 
             class="sidebar-author">
          <h3>${author_name}<br><span class="color-mid-green">${city_birth}</span></h3>
          <p class="text-label padtop light-gray">Author of</p>
          <p>${work_1}</p>
          <p>${work_2 || ''}</p>
        </div>`;
      searchresults.innerHTML += authorDetails;
    }

    // TODO: Remove this and the getOrdinalSuffix function, not being used anymore.
    // Function to get the century of a year
    function getCentury(year) {
      const century = Math.ceil(year / 100);
      return `${century}${getOrdinalSuffix(century)} Century`;
    }

    // Function to get the ordinal suffix of a number
    function getOrdinalSuffix(number) {
      const suffixes = ["th", "st", "nd", "rd"];
      const remainder = number % 100;
      const suffix = suffixes[(remainder - 20) % 10] || suffixes[remainder] || suffixes[0];
      return suffix;
    }

    // TODO: Remove country from this.
    // TODO: Consider not putting every value in this generator function so that search is faster.
    // Update setAuthorDetails to show more information
    function setAuthorDetails(properties, lat, long) {
      const {
        author_name,
        city_birth,
        city_residence,
        country,
        continent,
        year_birth,
        year_death,
        work_1,
        work_2,
        gender,
        language,
        awards,
        bio,
        list_title,
        list_bookname,
        list_copy,
        list_url
      } = properties;

      map.flyTo({
        center: [lat, long],
        zoom: 6
      });
      
      showAuthorDetails();

      // Create awards pill if awards exist
      const awardPills = awards ? awards.split(';').map(award => `<span class="pill">${award}</span>`).join('') : '';
      
      // Create language pill(s)
      const languagePills = language.split(';').map(lang => 
        `<span class="pill">${lang.trim()}</span>`
      ).join('');

      const featuredIn = list_title ? `
      
        <div class="card-title"><a href="${list_url}" target="_blank">${list_title}</a>
          <img src="icons/arrow-up-right.svg" alt="arrow-up-right">
          </div>
        <div class="card-content">
          <span class="book-title">${list_bookname}</span>
          <span>${list_copy}</span>
        </div>
      ` : '';
      
      sidebarauthordetails.innerHTML = `
        <h2>${author_name}</h2>
        <div class="lifetime">(${year_birth} - ${year_death ? year_death : 'Present'})</div>

        <div class="pill-container">
          <span class="pill">${continent}</span>
          <span class="pill">${gender}</span>
          ${languagePills}
          ${awardPills}
        </div>

        <p class="text-label padtop mid-gray">Author of</p>
        <p class="book">${work_1}</p>
        ${work_2 ? `<p class="book">${work_2}</p>` : ''}

        <div class="flex-equal">
          <div class="flex-1">
            <p class="text-label padtop mid-gray">Birthplace</p>
            <span class="color-mid-green">${city_birth}</span>
          </div>
          <div class="flex-1">
            <p class="text-label padtop mid-gray">Residence</p>
            <span class="color-mid-green">${city_residence}</span>
          </div>
        </div>

        ${bio ? `<p class="text-label padtop mid-gray">Bio</p><p class="bio">${bio}</p>` : ''}
        ${featuredIn}
      `;

    }

    // TODO: Obfuscate this access token somehow.
    // Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZ3lhbmwiLCJhIjoiY2swNmNoY29kMDA2ZzNjbWN4MmRvbHlmYiJ9.HJHfadzLE1cNqce2G51BEQ';

    // Initialize the map
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/gyanl/cls90czva01au01pld9fc7b5x',
      center: [2.0000, 89.0000],
      zoom: .5
    });

    // Add this after map initialization
    map.on('load', function () {
      // Animate to the desired zoom level
      document.getElementById('introButton').addEventListener('click', function () {

        // Animate out the intro button and text
        introButton.classList.replace("header-fade-in-down", "goAwayBottom");
        introText.classList.replace("header-fade-in-up", "goAwayTop");

        // Animate map to the desired zoom level
        map.easeTo({
          zoom: 4,
          center: [78.0000, 29.0000],
          duration: 1600 // Duration in milliseconds
        });

        // Wait some time and then show the sidebar and remove the intro button and text
        // The invisible elements cause problems if they are not removed
        setTimeout(() => {
          document.getElementById('sidebar').classList.remove('displaynone');
          document.getElementById('introButton').style.display = 'none';
          document.getElementById('introText').style.display = 'none';
        }, 1000); // Duration in milliseconds

      });

      // Rest of your existing map.on('load') code...
      map.addSource('authors', {
        type: 'geojson',
        data: 'data.geojson', // Path to GeoJSON file
        cluster: true,
        clusterMaxZoom: 14, // Max zoom to cluster points on
        clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)
      });

      // Use Mapbox GL JS's 'addLayer' function to add the points to the map.
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'authors',
        filter: ['has', 'point_count'],
        //Probably don't need this actually
        paint: {
          'circle-color': '#67FAAF',
          //Step function to set radius of unclustered circles
          'circle-radius': [
            'step',
            ['get', 'point_count'],
            15,
            10,
            20,
            20,
            30,
            30,
            40
          ]
        }
      });

      //Clustered circles
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'authors',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
          'text-size': 16,
        }
      });

      //Unclustered Points
      map.addLayer({
        id: 'unclustered-point',
        type: 'circle',
        source: 'authors',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': '#67FAAF',
          'circle-radius': 10,
        }
      });

      // Clicking on a point displays the author details in the sidebar
      map.on('click', 'unclustered-point', function (e) {
        var coordinates = e.features[0].geometry.coordinates.slice();
        var properties = e.features[0].properties;

        setSidebarTitle("1 result");
        clearSidebar();
        addAuthorResult(properties, coordinates);
        showSearchResults();

        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }
      });

      // Clicking on a cluster displays all points in cluster in sidebar
      map.on('click', 'clusters', function (e) {
        var features = map.queryRenderedFeatures(e.point, {
          layers: ['clusters']
        });
        var clusterId = features[0].properties.cluster_id;
        map.getSource('authors').getClusterLeaves(clusterId, 103, 0, function (err, leaves) {
          if (err) {
            return console.error('Error getting leaves of cluster: ', err);
          }
          clearSidebar();
          setSidebarTitle(leaves.length + " results");
          leaves.forEach(function (leaf) {
            addAuthorResult(
              leaf.properties,
              leaf.geometry.coordinates
            );
          });
        });
        showSearchResults();
      });

      // Debounce helper function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Function to handle search input
      const handleSearch = debounce((e) => {
        clearSidebar();
        e.preventDefault();
        const searchValue = e.target.value.toLowerCase();

        if (searchValue.length > 1) {
          // Make sure we're using the raw GeoJSON data, not the clustered features
          const features = window.data.features.filter(f =>
            f.properties.author_name.toLowerCase().includes(searchValue) ||
            f.properties.work_1.toLowerCase().includes(searchValue) ||
            f.properties.work_2.toLowerCase().includes(searchValue)
          );
          showResults(features);
          setSidebarTitle(features.length + " results");
        } else {
          setSidebarTitle("Search for your favourite author");
        }
      }, 150); // Reduced debounce delay to 150ms for better responsiveness

      // Function to handle map movement and show visible features
      async function showVisibleFeatures() {
        clearSidebar();
        const features = [];

        // Get all visible features
        const visibleFeatures = map.queryRenderedFeatures({
          layers: ['clusters', 'unclustered-point']
        });

        // Create promises for all cluster expansions
        const clusterPromises = visibleFeatures
          .filter(feature => feature.properties.cluster)
          .map(feature => {
            return new Promise((resolve, reject) => {
              map.getSource('authors').getClusterLeaves(
                feature.properties.cluster_id,
                100,  // Maximum number of points to retrieve
                0,    // Offset
                (err, leaves) => {
                  if (err) reject(err);
                  else resolve(leaves);
                }
              );
            });
          });

        // Add unclustered points directly
        visibleFeatures
          .filter(feature => !feature.properties.cluster && feature.properties.author_name)
          .forEach(feature => features.push(feature));

        try {
          // Wait for all cluster data
          const clusterResults = await Promise.all(clusterPromises);
          // Add all cluster points to features array
          clusterResults.forEach(clusterPoints => {
            features.push(...clusterPoints);
          });

          // More thorough deduplication using a Set to track seen authors
          const seen = new Set();
          const uniqueFeatures = features.filter(feature => {
            const authorName = feature.properties.author_name;
            if (!authorName || seen.has(authorName)) {
              return false;
            }
            seen.add(authorName);
            return true;
          });

          showResults(uniqueFeatures);
          setSidebarTitle(uniqueFeatures.length + " results");
        } catch (error) {
          console.error('Error getting cluster data:', error);
        }
      }

      // Helper function to display results
      function showResults(features) {
        // Clear existing results first
        clearSidebar();

        // Track authors we've already added
        const addedAuthors = new Set();

        features.forEach(feature => {
          if (feature.properties &&
            feature.properties.author_name &&
            !addedAuthors.has(feature.properties.author_name)) {  // Only add if not already added
            addAuthorResult(
              feature.properties,
              feature.geometry.coordinates
            );
            addedAuthors.add(feature.properties.author_name);
          }
        });
      }

      // Update event listeners
      document.getElementById('search-bar').addEventListener('input', handleSearch);
      map.on('moveend', debounce(showVisibleFeatures, 100));
      map.on('zoomend', debounce(showVisibleFeatures, 100));

      // Initial load
      showVisibleFeatures();
    });



    // Fly to a random location on the map when feeling lucky button is clicked
    document.getElementById('btnRandom').addEventListener('click', () => {
      const features = window.data.features;
      const randomFeature = features[Math.floor(Math.random() * features.length)];

      if (randomFeature && randomFeature.geometry) {
        map.flyTo({
          center: randomFeature.geometry.coordinates,
          zoom: 5
        });
      }
    });

    // Function to update the count badge for a dropdown
    function updateDropdownCount(dropdownId) {
      const dropdown = document.getElementById(dropdownId);
      const checkedBoxes = dropdown.querySelectorAll('input[type="checkbox"]:checked').length;

      if (checkedBoxes > 0) {
        dropdown.setAttribute('data-count', checkedBoxes);
        dropdown.classList.add('has-count');
      } else {
        dropdown.removeAttribute('data-count');
        dropdown.classList.remove('has-count');
      }
    }

    // Add event listeners to all checkboxes in dropdowns
    document.querySelectorAll('.dropdown input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', (event) => {
        const dropdownId = event.target.closest('.dropdown').id;
        updateDropdownCount(dropdownId);
      });
    });

    // Handling mobile dropdowns differently
    function setupMobileDropdowns() {
      if (window.innerWidth <= 768) {
        // Close dropdown when clicking outside
        document.addEventListener('click', (event) => {
          if (!event.target.closest('.dropdown')) {
            document.querySelectorAll('.dropdown-content').forEach(content => {
              content.style.display = 'none';
            });
            document.querySelectorAll('.dropdown').forEach(dropdown => {
              dropdown.classList.remove('header-link-active');
            });
          }
        });

        // Prevent body scroll when dropdown is open
        document.querySelectorAll('.dropdown').forEach(dropdown => {
          dropdown.addEventListener('click', () => {
            if (dropdown.classList.contains('header-link-active')) {
              document.body.style.overflow = 'hidden';
            } else {
              document.body.style.overflow = '';
            }
          });
        });
      }
    }

    // Call this function when the page loads and on resize
    window.addEventListener('load', setupMobileDropdowns);
    window.addEventListener('resize', setupMobileDropdowns);



    document.addEventListener('DOMContentLoaded', () => {

      // Show/hide clear button based on input content
      searchInput.addEventListener('input', () => {
        if (window.innerWidth >= mobileBreakpoint) {
          clearButton.style.display = searchInput.value ? 'block' : 'none';
        }
      });

      // Initialize clear button visibility
      if (window.innerWidth >= mobileBreakpoint) {
        clearButton.style.display = searchInput.value ? 'block' : 'none';
      }

    // When search bar is clicked, hide logo and filter on mobile
    searchBar.addEventListener('click', () => {
      if (window.innerWidth <= mobileBreakpoint) {
        logo.style.display = 'none';
        filter.style.display = 'none';
        clearButton.style.display = 'block';
      }
    });

    clearButton.addEventListener('click', () => {
      console.log('%c[clearButton] Clicked', 'color: #0af');

      console.log(
        '[clearButton]',
        'searchInput.value before clearing:', 
        searchInput.value
      );

      // Check if we have a value. If so, call backToTheResults().
      if (searchInput.value !== '') {
        console.log('[clearButton] Calling backToTheResults()');
        backToTheResults();
      }

      // Remove focus from the input
      searchInput.blur();

      // Force an 'input' event to re-trigger search logic
      console.log('[clearButton] Dispatching "input" event on searchInput');
      searchInput.dispatchEvent(new Event('input'));

      // Clear the search box
      searchInput.value = '';

      // Check the mobile breakpoint
      console.log('[clearButton]', 'window.innerWidth:', window.innerWidth, 'mobileBreakpoint:', mobileBreakpoint);

      // Debug the current inline display for logo and filter BEFORE we modify them
      console.log(
        '[clearButton]',
        'logo.style.display BEFORE:', `"${logo.style.display}"`,
        'filter.style.display BEFORE:', `"${filter.style.display}"`
      );

      // Depending on your intended logic, you might revert or set them to block here
      if (window.innerWidth >= mobileBreakpoint) {
        // Desktop
        console.log('[clearButton] Desktop logic - setting display to block');
        logo.style.display = 'block';
        filter.style.display = 'block';
        clearButton.style.display = 'none';
      } else {
        // Mobile
        console.log('[clearButton] Mobile logic - removing inline display override');
        logo.style.display = '';
        filter.style.display = '';
        clearButton.style.display = 'block';
      }

      // Debug the final inline display for logo and filter AFTER we modify them
      console.log(
        '[clearButton]',
        'logo.style.display AFTER:', `"${logo.style.display}"`,
        'filter.style.display AFTER:', `"${filter.style.display}"`
      );
    });

    filter.addEventListener('click', showFilters);

    function showFilters() {
      console.log('%c[showFilters] Called', 'color: #0af');
      console.log(
        '[showFilters]',
        'headerLinks.style.display before:', `"${headerLinks.style.display}"`,
        'logo.style.display before:', `"${logo.style.display}"`
      );

      headerLinks.style.display = 'flex';
      logo.style.display = 'none';

      console.log(
        '[showFilters]',
        'headerLinks.style.display after:', `"${headerLinks.style.display}"`,
        'logo.style.display after:', `"${logo.style.display}"`
      );
    }

    });

  </script>

</body>

</html>