<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Lit Map</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <!-- Stylesheets -->
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Instrument+Sans:ital,wght@0,400;1,500&display=swap">

  <!-- Scripts -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@mapbox/mapbox-sdk/umd/mapbox-sdk.min.js"></script>

</head>

<body>

  <h1 id="introText" class="landing header-fade-in-up">
    <img class="logo" src="hammock-white.png">
    <p>
      Explore the Globe&rsquo;s Literary Legacy <br>One City at a Time
    </p>
  </h1>

  <div id="tutorial-bottom" class="center-align bottom-center header-fade-in-down">

    <div class="tutorial-card-container">
      <div class="tutorial-card glass">
        <img src="icons/maximize-2.svg" alt="zoom">
        Scroll or pinch to zoom in and out.
      </div>

      <div class="tutorial-card glass">
        <img src="icons/move.svg" alt="zoom">
        Click and drag to move around the globe.
      </div>

      <div class="tutorial-card glass">
        <img src="icons/mouse-pointer.svg" alt="zoom">
        Click on a green dot to see more about the authors from that region.
      </div>
    </div>

    <div class="tutorial-card-container">
      <a href="https://www.hammockmag.com">
        <button type="button" class="button-quaternary">
          About this Map
        </button>
      </a>
      <button id="introButton" type="button" class="button-tertiary">
        Get Started
      </button>
    </div>
  </div>

  <div id="map"></div>


  <header id="header" class="glass displaynone">
    <a href="https://www.hammockmag.com"><img id="logo" class="logo" src="hammock-white.png"></a>
    <div class="header-links">


      <div class="header-link dropdown" id="continent-dropdown">
        Continents
        <div class="dropdown-content">
          <label><input type="checkbox"> Africa</label>
          <label><input type="checkbox"> Asia</label>
          <label><input type="checkbox"> Australia</label>
          <label><input type="checkbox"> Europe</label>
          <label><input type="checkbox"> North America</label>
          <label><input type="checkbox"> Latin America</label>
        </div>
      </div>

      <div class="header-link dropdown" id="gender-dropdown">
        Gender
        <div class="dropdown-content">
          <label><input type="checkbox"> Male</label>
          <label><input type="checkbox"> Female</label>
          <label><input type="checkbox"> Non-binary</label>
        </div>
      </div>

      <div class="header-link dropdown" id="awards-dropdown">
        Awards
        <div class="dropdown-content">
          <label><input type="checkbox"> Prix Goncourt</label>
          <label><input type="checkbox"> International Booker Prize</label>
          <label><input type="checkbox"> Neustadt International Prize</label>
          <label><input type="checkbox"> Grand Prix National des Lettres</label>
          <label><input type="checkbox"> Camoes Prize</label>
          <label><input type="checkbox"> IMPAC Dublin Literary Award</label>
          <label><input type="checkbox"> Cervantes Prize</label>
          <label><input type="checkbox"> Prix Medicis</label>
          <label><input type="checkbox"> Pulitzer Prize</label>
          <label><input type="checkbox"> Booker Prize</label>
          <label><input type="checkbox"> Independent Foreign Fiction Prize</label>
          <label><input type="checkbox"> National Book Award</label>
          <label><input type="checkbox"> Nobel Prize</label>
          <label><input type="checkbox"> Commonwealth Writers' Prize</label>
          <label><input type="checkbox"> Buchner Prize</label>
          <label><input type="checkbox"> Buchner Prize (returned)</label>
          <label><input type="checkbox"> Commonwealth Prize</label>
        </div>
      </div>

      <div class="header-link dropdown" id="language-dropdown">
        Language
        <div class="dropdown-content">
          <label><input type="checkbox"> Afrikaans</label>
          <label><input type="checkbox"> Albanian</label>
          <label><input type="checkbox"> Arabic</label>
          <label><input type="checkbox"> Bahasa</label>
          <label><input type="checkbox"> Bengali</label>
          <label><input type="checkbox"> Bulgarian</label>
          <label><input type="checkbox"> Chinese</label>
          <label><input type="checkbox"> Croatian</label>
          <label><input type="checkbox"> Czech</label>
          <label><input type="checkbox"> Danish</label>
          <label><input type="checkbox"> Dutch</label>
          <label><input type="checkbox"> English</label>
          <label><input type="checkbox"> Finnish</label>
          <label><input type="checkbox"> French</label>
          <label><input type="checkbox"> Georgian</label>
          <label><input type="checkbox"> German</label>
          <label><input type="checkbox"> Greek</label>
          <label><input type="checkbox"> Hebrew</label>
          <label><input type="checkbox"> Hindi</label>
          <label><input type="checkbox"> Hungarian</label>
          <label><input type="checkbox"> Icelandic</label>
          <label><input type="checkbox"> Italian</label>
          <label><input type="checkbox"> Japanese</label>
          <label><input type="checkbox"> Kannada</label>
          <label><input type="checkbox"> Kiswahili</label>
          <label><input type="checkbox"> Korean</label>
          <label><input type="checkbox"> Malayalam</label>
          <label><input type="checkbox"> Norwegian</label>
          <label><input type="checkbox"> Persian</label>
          <label><input type="checkbox"> Polish</label>
          <label><input type="checkbox"> Portuguese</label>
          <label><input type="checkbox"> Punjabi</label>
          <label><input type="checkbox"> Romanian</label>
          <label><input type="checkbox"> Russian</label>
          <label><input type="checkbox"> Serbo-Croatian</label>
          <label><input type="checkbox"> Somali</label>
          <label><input type="checkbox"> Spanish</label>
          <label><input type="checkbox"> Swedish</label>
          <label><input type="checkbox"> Tamil</label>
          <label><input type="checkbox"> Turkish</label>
          <label><input type="checkbox"> Ukrainian</label>
          <label><input type="checkbox"> Urdu</label>
          <label><input type="checkbox"> Yiddish</label>
        </div>
      </div>

    </div>

    <div id="search-bar">
      <input id="search-input" type="text" placeholder="Search" enterkeyhint="search">
      <button id="search-clear" type="button" class="search-clear" aria-label="Clear search">
        <img class="icon-x" src="icons/x.svg"></button>
    </div>
    <button class="button-secondary desktop-only" id="btnRandom">
      <span>Feeling lucky</span>
      <div class="icon-circle"><img width="16px" src="icons/shuffle.svg" alt="Shuffle icon"></div>
    </button>

    </div>
  </header>

  <div id="sidebar" class="sidebar glass displaynone fade-in-up">

    <div id="sidebar-search-title-container" class="glass">
      <span id="sidebar-search-title">
        Result
      </span>
      <button onclick="toggleSidebar()" class="button-primary">
        <img id="chevron" width="16px" src="icons/chevron-up.svg"></button>
    </div>

    <div id="sidebar-search-results" class="sidebar-body"></div>

    <div id="sidebar-author-title" class="sidebar-title fade-in-right glass" onclick="backToTheResults()">
      <img class="icon-left" src="icons/chevron-left.svg" alt="back"> Back
    </div>

    <div id="sidebar-author-details" class="sidebar-author-details"></div>

  </div>

  <script>

    // Convenient names for the elements
    const logo = document.getElementById('logo');
    const filter = document.getElementById('filter');

    const searchBar = document.querySelector('#search-bar');
    const searchInput = document.getElementById('search-input');
    const clearButton = document.getElementById('search-clear');

    const searchtitle = document.getElementById('sidebar-search-title');
    const searchtitlecontainer = document.getElementById('sidebar-search-title-container');
    const searchresults = document.getElementById('sidebar-search-results');

    const sidebarauthortitle = document.getElementById('sidebar-author-title');
    const sidebarauthordetails = document.getElementById('sidebar-author-details');

    const titlechevron = document.getElementById('chevron');
    const mobileBreakpoint = 768;
    const headerLinks = document.querySelector('.header-links');

    const tutorialBottom = document.getElementById('tutorial-bottom');

    let tutorialComplete = false;

    // Fetch the data.geojson file with the authors data
    fetch('data.geojson').then(response => response.json()).then(data => {
      window.data = data;
    });

    // TODO: Add constants for zoom levels.

    // Function to toggle dropdown content visibility
    function toggleDropdown(dropdownId) {
      // Close all other dropdowns first
      document.querySelectorAll('.dropdown').forEach(dropdown => {
        if (dropdown.id !== dropdownId) {
          dropdown.classList.remove('header-link-active');
          dropdown.querySelector('.dropdown-content').style.display = 'none';
        }
      });

      // Toggle the clicked dropdown
      const dropdown = document.getElementById(dropdownId);
      dropdown.classList.toggle('header-link-active');
      const dropdownContent = dropdown.querySelector('.dropdown-content');
      dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
    }

    // Add click event listeners to all dropdown headers
    document.querySelectorAll('.dropdown').forEach(dropdown => {
      dropdown.addEventListener('click', (event) => {
        // Prevent the click from propagating to the document
        event.stopPropagation();
        toggleDropdown(dropdown.id);
      });
    });

    // Close all dropdowns when clicking outside
    document.addEventListener('click', () => {
      document.querySelectorAll('.dropdown').forEach(dropdown => {
        const content = dropdown.querySelector('.dropdown-content');
        content.style.display = 'none';
        dropdown.classList.remove('header-link-active');
      });
    });

    // Prevent clicks inside dropdown content from closing the dropdown
    document.querySelectorAll('.dropdown-content').forEach(content => {
      content.addEventListener('click', (event) => {
        event.stopPropagation();
      });
    });



    // Toggles the sidebar
    function toggleSidebar() {
      searchresults.style.display = searchresults.style.display === 'none' ? 'block' : 'none';
      titlechevron.style.rotate = titlechevron.style.rotate === '180deg' ? '0deg' : '180deg';
    }

    // Sets the sidebar title
    function setSidebarTitle(input) {
      searchtitle.innerHTML = input;
    }

    // Clears the sidebar
    function clearSidebar() {
      searchresults.innerHTML = "";
    }

    // Shows author details in sidebar
    function showAuthorDetails() {
      searchtitlecontainer.style.display = "none";
      searchresults.style.display = "none";

      sidebarauthortitle.style.display = "flex";
      sidebarauthordetails.style.display = "block";
    }

    // Shows results in sidebar
    function showSearchResults() {
      searchtitlecontainer.style.display = "flex";
      searchresults.style.display = "block";

      sidebarauthortitle.style.display = "none";
      sidebarauthordetails.style.display = "none";
    }

    // Shows results in sidebar and zooms out on map
    function backToTheResults() {
      console.log('%c[backToTheResults] Called', 'color: #0af');
      map.easeTo({
        zoom: map.getZoom() - 0.5
      });
      console.log('[backToTheResults] -> showSearchResults() called, map flyTo zoom=3');
      showSearchResults();
    }

    // Update the addAuthorResult function to include more details
    function addAuthorResult(properties, coordinates) {
      const {
        author_name,
        city_birth,
        city_residence,
        country,
        continent,
        year_birth,
        year_death,
        work_1,
        work_2,
        gender,
        language,
        awards,
        bio,
        list_title,
        list_bookname,
        list_copy,
        list_url
      } = properties;

      var authorDetails = `
        <div onclick="setAuthorDetails(${JSON.stringify(properties).replace(/"/g, '&quot;')}, ${coordinates[0]}, ${coordinates[1]})" 
             class="sidebar-author">
          <h3>${author_name}<br><span class="color-mid-green">${city_birth}</span></h3>
          <p class="text-label padtop light-gray">Author of</p>
          <p>${work_1}</p>
          <p>${work_2 || ''}</p>
        </div>`;
      searchresults.innerHTML += authorDetails;
    }

    // TODO: Remove this and the getOrdinalSuffix function, not being used anymore.
    // Function to get the century of a year
    function getCentury(year) {
      const century = Math.ceil(year / 100);
      return `${century}${getOrdinalSuffix(century)} Century`;
    }

    // Function to get the ordinal suffix of a number
    function getOrdinalSuffix(number) {
      const suffixes = ["th", "st", "nd", "rd"];
      const remainder = number % 100;
      const suffix = suffixes[(remainder - 20) % 10] || suffixes[remainder] || suffixes[0];
      return suffix;
    }

    // TODO: Remove country from this.
    // TODO: Consider not putting every value in this generator function so that search is faster.
    // Update setAuthorDetails to show more information
    function setAuthorDetails(properties, lat, long) {
      const {
        author_name,
        city_birth,
        city_residence,
        country,
        continent,
        year_birth,
        year_death,
        work_1,
        work_2,
        gender,
        language,
        awards,
        bio,
        list_title,
        list_bookname,
        list_copy,
        list_url
      } = properties;

      map.flyTo({
        center: [lat, long],
        zoom: 6
      });

      showAuthorDetails();

      // Create awards pill if awards exist
      const awardPills = awards ? awards.split(';').map(award => `<span class="pill">${award}</span>`).join('') : '';

      // Create language pill(s)
      const languagePills = language.split(';').map(lang =>
        `<span class="pill">${lang.trim()}</span>`
      ).join('');

      const featuredIn = list_title ? `
      
        <a href="${list_url}" target="_blank"><div class="card-title">${list_title}
          <img src="icons/arrow-up-right.svg" alt="arrow-up-right">
          </div>
          </a>
        <div class="card-content">
          <span class="book-title">${list_bookname}</span>
          <span>${list_copy}</span>
        </div>
      ` : '';

      sidebarauthordetails.innerHTML = `
        <h2>${author_name}</h2>
        <div class="lifetime">(${year_birth} - ${year_death ? year_death : 'Present'})</div>

        <div class="pill-container">
          <span class="pill">${continent}</span>
          <span class="pill">${gender}</span>
          ${languagePills}
          ${awardPills}
        </div>

        <p class="text-label padtop mid-gray">Author of</p>
        <p class="book">${work_1}</p>
        ${work_2 ? `<p class="book">${work_2}</p>` : ''}

        <div class="flex-equal">
          <div class="flex-1">
            <p class="text-label padtop mid-gray">Birthplace</p>
            <span class="color-mid-green">${city_birth}</span>
          </div>
          <div class="flex-1">
            <p class="text-label padtop mid-gray">Residence</p>
            <span class="color-mid-green">${city_residence}</span>
          </div>
        </div>

        ${bio ? `<p class="text-label padtop mid-gray">Bio</p><p class="bio">${bio}</p>` : ''}
        ${featuredIn}
      `;

    }

    // TODO: Obfuscate this access token somehow.
    // Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZ3lhbmwiLCJhIjoiY2swNmNoY29kMDA2ZzNjbWN4MmRvbHlmYiJ9.HJHfadzLE1cNqce2G51BEQ';

    // Initialize the map
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/gyanl/cls90czva01au01pld9fc7b5x',
      center: [2.0000, 89.0000],
      zoom: .5
    });

    // Add this after map initialization
    map.on('load', function () {


      // If the user clicks intro buttom, start the experience
      document.getElementById('introButton').addEventListener('click', startExperience);

      // Start the experience by animating out the tutorial parts
      function startExperience(lat, long) {
        clearSidebar(); //so that the sidebar doesn't show the no results message
        tutorialComplete = true;
        introText.classList.replace("header-fade-in-up", "goAwayTop");
        tutorialBottom.classList.replace("header-fade-in-down", "goAwayBottom");

        // If lat and long are provided, use them. Otherwise use default coordinates
        const targetCoords = (lat && long) 
          ? [long, lat]
          : [78.0000, 29.0000];

        // Use easeTo for default case, flyTo for specific coordinates
        if (lat && long) {
          map.flyTo({
            center: targetCoords,
            zoom: 4,
            duration: 1600
          });
        } else {
          map.easeTo({
            center: targetCoords,
            zoom: 4,
            duration: 1600
          });
        }

        // Wait some time and then show the sidebar and remove the intro button and text
        setTimeout(() => {
          document.getElementById('header').classList.remove('displaynone');
          document.getElementById('sidebar').classList.remove('displaynone');
          introText.style.display = 'none';
          tutorialBottom.style.display = 'none';
        }, 900);
      }

      // Rest of your existing map.on('load') code...
      map.addSource('authors', {
        type: 'geojson',
        data: 'data.geojson', // Path to GeoJSON file
        cluster: true,
        clusterMaxZoom: 14, // Max zoom to cluster points on
        clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)
      });

      // Use Mapbox GL JS's 'addLayer' function to add the points to the map.
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'authors',
        filter: ['has', 'point_count'],
        //Probably don't need this actually
        paint: {
          'circle-color': '#67FAAF',
          //Step function to set radius of unclustered circles
          'circle-radius': [
            'step',
            ['get', 'point_count'],
            15,
            10,
            20,
            20,
            30,
            30,
            40
          ]
        }
      });

      //Clustered circles
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'authors',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
          'text-size': 16,
        }
      });

      //Unclustered Points
      map.addLayer({
        id: 'unclustered-point',
        type: 'circle',
        source: 'authors',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': '#67FAAF',
          'circle-radius': 10,
        }
      });

      // Clicking on a point displays the author details in the sidebar
      map.on('click', 'unclustered-point', function (e) {

        if (!tutorialComplete) {
          startExperience(e.lngLat.lat, e.lngLat.lng);
          return;
        }

        var coordinates = e.features[0].geometry.coordinates.slice();
        var properties = e.features[0].properties;

        setSidebarTitle("1 result");
        clearSidebar();
        addAuthorResult(properties, coordinates);
        showSearchResults();

        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }
      });

      // Clicking on a cluster displays all points in cluster in sidebar
      map.on('click', 'clusters', function (e) {
        if (!tutorialComplete) {
          startExperience(e.lngLat.lat, e.lngLat.lng);
        }

        var features = map.queryRenderedFeatures(e.point, {
          layers: ['clusters']
        });
        var clusterId = features[0].properties.cluster_id;
        map.getSource('authors').getClusterLeaves(clusterId, 103, 0, function (err, leaves) {
          if (err) {
            return console.error('Error getting leaves of cluster: ', err);
          }
          clearSidebar();
          setSidebarTitle(leaves.length + " results");
          leaves.forEach(function (leaf) {
            addAuthorResult(
              leaf.properties,
              leaf.geometry.coordinates
            );
          });
        });
        showSearchResults();
      });

      // Debounce helper function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // First, define handleSearch
      const handleSearch = debounce((e) => {
        clearSidebar();
        applyFilters();
      }, 150);

      // Then, set up the event listeners
      document.querySelectorAll('.dropdown input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          // Call applyFilters instead of handleSearch
          applyFilters();

          // Update the count badge
          const dropdownId = checkbox.closest('.dropdown').id;
          updateDropdownCount(dropdownId);
        });
      });

      // Helper function to display results
      function showResults(features) {
        clearSidebar();
        const totalCount = features.length;
        const displayLimit = 100;

        // Track authors we've already added
        const addedAuthors = new Set();
        let displayedCount = 0;

        for (const feature of features) {
          if (displayedCount >= displayLimit) break;

          if (feature.properties?.author_name &&
            !addedAuthors.has(feature.properties.author_name)) {
            addAuthorResult(
              feature.properties,
              feature.geometry.coordinates
            );
            addedAuthors.add(feature.properties.author_name);
            displayedCount++;
          }
        }
        
        // Update sidebar title to show total count
        if (totalCount > 0) {
          setSidebarTitle(`${totalCount > displayLimit ? `${displayLimit}+ results` : `${totalCount} results`}`);
        } else {
          setSidebarTitle("No results found");
          searchresults.innerHTML = `
        <div class="sidebar-author">
          <h3>We couldn't find this book or author.</h3>
          <p>If you think they should be there, fill out this form!</p>
        </div>
          `;
        }
    }

      // Optimized showVisibleFeatures function
      async function showVisibleFeatures() {
        clearSidebar();
        const features = [];
        const displayLimit = 100;

        // Get visible features
        const visibleFeatures = map.queryRenderedFeatures({
          layers: ['clusters', 'unclustered-point']
        });

        // Handle unclustered points first (faster)
        const unclusteredFeatures = visibleFeatures
          .filter(feature => !feature.properties.cluster && feature.properties.author_name);

        // If we already have enough unclustered points, we can skip cluster processing
        if (unclusteredFeatures.length >= displayLimit) {
          showResults(unclusteredFeatures);
          return;
        }

        features.push(...unclusteredFeatures);

        // Process clusters only if we need more results
        const clusterPromises = visibleFeatures
          .filter(feature => feature.properties.cluster)
          .map(feature => {
            return new Promise((resolve, reject) => {
              map.getSource('authors').getClusterLeaves(
                feature.properties.cluster_id,
                displayLimit, // Only request up to displayLimit
                0,
                (err, leaves) => err ? reject(err) : resolve(leaves)
              );
            });
          });

        try {
          const clusterResults = await Promise.all(clusterPromises);
          clusterResults.forEach(clusterPoints => {
            features.push(...clusterPoints);
          });

          // Deduplicate results
          const seen = new Set();
          const uniqueFeatures = features.filter(feature => {
            const authorName = feature.properties.author_name;
            if (!authorName || seen.has(authorName)) return false;
            seen.add(authorName);
            return true;
          });

          showResults(uniqueFeatures);
        } catch (error) {
          console.error('Error getting cluster data:', error);
        }
      }

      // Update event listeners
      document.getElementById('search-bar').addEventListener('input', handleSearch);
      map.on('moveend', debounce(showVisibleFeatures, 100));
      map.on('zoomend', debounce(showVisibleFeatures, 100));

      function getActiveFilters() {
        const filters = {
          gender: [],
          continent: [],
          language: [],
          awards: []
        };

        // Collect checked values using label text instead of IDs
        document.querySelectorAll('#gender-dropdown input:checked').forEach(checkbox => {
          filters.gender.push(checkbox.closest('label').textContent.trim().toLowerCase());
        });

        document.querySelectorAll('#continent-dropdown input:checked').forEach(checkbox => {
          filters.continent.push(checkbox.closest('label').textContent.trim());
        });

        document.querySelectorAll('#language-dropdown input:checked').forEach(checkbox => {
          filters.language.push(checkbox.closest('label').textContent.trim());
        });

        document.querySelectorAll('#awards-dropdown input:checked').forEach(checkbox => {
          filters.awards.push(checkbox.closest('label').textContent.trim());
        });

        return filters;
      }

      function applyFilters() {
        const searchValue = searchInput.value.toLowerCase();
        const activeFilters = getActiveFilters();

        // Build up the filtered list
        const filteredFeatures = window.data.features.filter(f => {
          const props = f.properties;

          // Search text logic
          const matchesSearch =
            searchValue.length <= 1
            || (props.author_name.toLowerCase().includes(searchValue))
            || (props.work_1.toLowerCase().includes(searchValue))
            || (props.work_2 && props.work_2.toLowerCase().includes(searchValue));

          // Filter logic
          const matchesGender = activeFilters.gender.length === 0
            || activeFilters.gender.includes(props.gender.toLowerCase());
          const matchesContinent = activeFilters.continent.length === 0
            || activeFilters.continent.includes(props.continent);
          const matchesLanguage = activeFilters.language.length === 0
            || (props.language && props.language
              .split(';')
              .some(lang => activeFilters.language.includes(lang.trim())));
          const matchesAwards = activeFilters.awards.length === 0
            || (props.awards && props.awards
              .split(';')
              .some(award => activeFilters.awards.includes(award.trim())));

          // Final check
          return matchesSearch && matchesGender && matchesContinent && matchesLanguage && matchesAwards;
        });

        // Create a fresh GeoJSON with filtered features
        const newData = {
          ...window.data,
          features: filteredFeatures
        };

        // Now update the map source with only the filtered data
        map.getSource('authors').setData(newData);

        // Update sidebar, e.g. show the newly filtered features
        showResults(filteredFeatures);
      }

      // Initial load
      showVisibleFeatures();
    });



    // Fly to a random location on the map when feeling lucky button is clicked
    document.getElementById('btnRandom').addEventListener('click', () => {
      const features = window.data.features;
      const randomFeature = features[Math.floor(Math.random() * features.length)];

      if (randomFeature && randomFeature.geometry) {
        map.flyTo({
          center: randomFeature.geometry.coordinates,
          zoom: 5
        });
      }
    });

    // Function to update the count badge for a dropdown
    function updateDropdownCount(dropdownId) {
      const dropdown = document.getElementById(dropdownId);
      const checkedBoxes = dropdown.querySelectorAll('input[type="checkbox"]:checked').length;

      if (checkedBoxes > 0) {
        dropdown.setAttribute('data-count', checkedBoxes);
        dropdown.classList.add('has-count');
      } else {
        dropdown.removeAttribute('data-count');
        dropdown.classList.remove('has-count');
      }
    }

    // Handling mobile dropdowns differently
    function setupMobileDropdowns() {
      if (window.innerWidth <= 768) {
        // Close dropdown when clicking outside
        document.addEventListener('click', (event) => {
          if (!event.target.closest('.dropdown')) {
            document.querySelectorAll('.dropdown-content').forEach(content => {
              content.style.display = 'none';
            });
            document.querySelectorAll('.dropdown').forEach(dropdown => {
              dropdown.classList.remove('header-link-active');
            });
          }
        });

        // Prevent body scroll when dropdown is open
        document.querySelectorAll('.dropdown').forEach(dropdown => {
          dropdown.addEventListener('click', () => {
            if (dropdown.classList.contains('header-link-active')) {
              document.body.style.overflow = 'hidden';
            } else {
              document.body.style.overflow = '';
            }
          });
        });
      }
    }

    // Call this function when the page loads and on resize
    window.addEventListener('load', setupMobileDropdowns);
    window.addEventListener('resize', setupMobileDropdowns);



    document.addEventListener('DOMContentLoaded', () => {

      // Show/hide clear button based on input content
      searchInput.addEventListener('input', () => {
        if (window.innerWidth >= mobileBreakpoint) {
          clearButton.style.display = searchInput.value ? 'block' : 'none';
        }
      });

      // Initialize clear button visibility
      if (window.innerWidth >= mobileBreakpoint) {
        clearButton.style.display = searchInput.value ? 'block' : 'none';
      }

      // When search bar is clicked, hide logo and filter on mobile
      searchBar.addEventListener('click', () => {
        if (window.innerWidth <= mobileBreakpoint) {
          logo.style.display = 'none';
          filter.style.display = 'none';
          clearButton.style.display = 'block';
        }
      });

      clearButton.addEventListener('click', () => {
        console.log('%c[clearButton] Clicked', 'color: #0af');

        console.log(
          '[clearButton]',
          'searchInput.value before clearing:',
          searchInput.value
        );

        // Check if we have a value. If so, call backToTheResults().
        if (searchInput.value !== '') {
          console.log('[clearButton] Calling backToTheResults()');
          backToTheResults();
        }

        // Remove focus from the input
        searchInput.blur();

        // Force an 'input' event to re-trigger search logic
        console.log('[clearButton] Dispatching "input" event on searchInput');
        searchInput.dispatchEvent(new Event('input'));

        // Clear the search box
        searchInput.value = '';

        // Check the mobile breakpoint
        console.log('[clearButton]', 'window.innerWidth:', window.innerWidth, 'mobileBreakpoint:', mobileBreakpoint);

        // Debug the current inline display for logo and filter BEFORE we modify them
        console.log(
          '[clearButton]',
          'logo.style.display BEFORE:', `"${logo.style.display}"`,
          'filter.style.display BEFORE:', `"${filter.style.display}"`
        );

        // Depending on your intended logic, you might revert or set them to block here
        if (window.innerWidth >= mobileBreakpoint) {
          // Desktop
          console.log('[clearButton] Desktop logic - setting display to block');
          logo.style.display = 'block';
          filter.style.display = 'block';
          clearButton.style.display = 'none';
        } else {
          // Mobile
          console.log('[clearButton] Mobile logic - removing inline display override');
          logo.style.display = '';
          filter.style.display = '';
          clearButton.style.display = 'block';
        }

        // Debug the final inline display for logo and filter AFTER we modify them
        console.log(
          '[clearButton]',
          'logo.style.display AFTER:', `"${logo.style.display}"`,
          'filter.style.display AFTER:', `"${filter.style.display}"`
        );
      });

      filter.addEventListener('click', showFilters);

      function showFilters() {
        console.log('%c[showFilters] Called', 'color: #0af');
        console.log(
          '[showFilters]',
          'headerLinks.style.display before:', `"${headerLinks.style.display}"`,
          'logo.style.display before:', `"${logo.style.display}"`
        );

        headerLinks.style.display = 'flex';
        logo.style.display = 'none';

        console.log(
          '[showFilters]',
          'headerLinks.style.display after:', `"${headerLinks.style.display}"`,
          'logo.style.display after:', `"${logo.style.display}"`
        );
      }

    });



  </script>

</body>

</html>