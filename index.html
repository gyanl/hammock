<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Lit Map</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <!-- Stylesheets -->
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.css">
  <!-- Link to Google Fonts for Instrument Sans -->
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Sans&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Sans:wght@500&display=swap" rel="stylesheet">
  <!-- Scripts -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@mapbox/mapbox-sdk/umd/mapbox-sdk.min.js"></script>
  <script src="js/slideshow.js"></script>

</head>

<body>
  <button type="button" class="button-tertiary landing header-fade-in-up" id="aboutButton">
    About this Map <img class="icon-circle" src="icons/info.svg" width="16px" alt="info">
  </button>
  <div id="aboutContainer" class="about-container landing displaynone header-fade-in-down-fast">
    <div class="about-content">
      <p>At Hammock, one of the pillars of what we do is providing literary recommendations, lists and avenues for
        discovering new books. So creating an interactive map that you can explore to get author recommendations felt
        like a natural fit.
      </p>
      <p>It felt surprising and almost unbelievable that a tool like this didn't already exist. Although we found
        specific versions or localised examples, the idea of one place where you could select a country or region of the
        world and get specific literary fiction recommendations was appealing.
      </p>
      <p>Creating a database of nearly 800 authors from the 20th and 21st century with various criteria we selected, we
        made this for you to browse, search and share.
      </p>

      <a href="https://www.hammockmag.com/about/methodology">
        <button type="button" class="button-gray">
          Read About Our Methodology
          <img class="icon-circle-white" src="icons/arrow-up-right-gray.svg" width="16px" alt="info">
        </button>
      </a>
    </div>
  </div>

  <div id="introText" class="landing header-fade-in-up">
    <span class="bold">Literary Map</span> by
    <img class="logo" src="hammock-white.png">
    <h1 class="max-width">
      Discover great fiction writers from around the globe
      <button id="introButton" type="button" class="inline button-tertiary">
        Start Exploring <img class="icon-circle-dark" src="icons/arrow-right.svg" width="16px" alt="chevron">
      </button>
    </h1>

  </div>

  <div id="tutorial-bottom" class="center-align bottom-center header-fade-in-down">

    <div class="tutorial-card-container" id="slideshow-container">
      <div class="tutorial-card glass">
        <img src="icons/maximize-2.svg" alt="zoom">
        Scroll or pinch to zoom in and out.
      </div>

      <div class="tutorial-card glass">
        <img src="icons/move.svg" alt="zoom">
        Click and drag to move around the globe.
      </div>

      <div class="tutorial-card glass">
        <img src="icons/mouse-pointer.svg" alt="zoom">
        Click on a green dot to see more about the authors.
      </div>
    </div>


  </div>

  <div id="map"></div>


  <header id="header" class="glass displaynone">
    <a href="https://www.hammockmag.com" id="logo" class="header-logo"></a>
    <div class="header-links">


      <div class="header-link dropdown" id="continent-dropdown">
        Continents
        <div class="dropdown-content">
          <label><input type="checkbox"> Africa</label>
          <label><input type="checkbox"> Asia</label>
          <label><input type="checkbox"> Australia</label>
          <label><input type="checkbox"> Europe</label>
          <label><input type="checkbox"> North America</label>
          <label><input type="checkbox"> Latin America</label>
        </div>
      </div>

      <div class="header-link dropdown" id="gender-dropdown">
        Gender
        <div class="dropdown-content">
          <label><input type="checkbox"> Male</label>
          <label><input type="checkbox"> Female</label>
          <label><input type="checkbox"> Non-binary</label>
        </div>
      </div>

      <div class="header-link dropdown" id="awards-dropdown">
        Awards
        <div class="dropdown-content">
          <label><input type="checkbox"> Booker Prize</label>
          <label><input type="checkbox"> Buchner Prize</label>
          <label><input type="checkbox"> Camoes Prize</label>
          <label><input type="checkbox"> Cervantes Prize</label>
          <label><input type="checkbox"> Commonwealth Prize</label>
          <label><input type="checkbox"> Commonwealth Writers' Prize</label>
          <label><input type="checkbox"> Grand Prix National des Lettres</label>
          <label><input type="checkbox"> IMPAC Dublin Literary Award</label>
          <label><input type="checkbox"> Independent Foreign Fiction Prize</label>
          <label><input type="checkbox"> International Booker Prize</label>
          <label><input type="checkbox"> National Book Award</label>
          <label><input type="checkbox"> Neustadt International Prize</label>
          <label><input type="checkbox"> Nobel Prize</label>
          <label><input type="checkbox"> Prix Goncourt</label>
          <label><input type="checkbox"> Prix Medicis</label>
          <label><input type="checkbox"> Pulitzer Prize</label>
        </div>
      </div>

      <div class="header-link dropdown" id="language-dropdown">
        Language
        <div class="dropdown-content">
          <label><input type="checkbox"> Afrikaans</label>
          <label><input type="checkbox"> Albanian</label>
          <label><input type="checkbox"> Arabic</label>
          <label><input type="checkbox"> Bahasa</label>
          <label><input type="checkbox"> Bengali</label>
          <label><input type="checkbox"> Bulgarian</label>
          <label><input type="checkbox"> Chinese</label>
          <label><input type="checkbox"> Croatian</label>
          <label><input type="checkbox"> Czech</label>
          <label><input type="checkbox"> Danish</label>
          <label><input type="checkbox"> Dutch</label>
          <label><input type="checkbox"> English</label>
          <label><input type="checkbox"> Finnish</label>
          <label><input type="checkbox"> French</label>
          <label><input type="checkbox"> Georgian</label>
          <label><input type="checkbox"> German</label>
          <label><input type="checkbox"> Greek</label>
          <label><input type="checkbox"> Hebrew</label>
          <label><input type="checkbox"> Hindi</label>
          <label><input type="checkbox"> Hungarian</label>
          <label><input type="checkbox"> Icelandic</label>
          <label><input type="checkbox"> Italian</label>
          <label><input type="checkbox"> Japanese</label>
          <label><input type="checkbox"> Kannada</label>
          <label><input type="checkbox"> Kiswahili</label>
          <label><input type="checkbox"> Korean</label>
          <label><input type="checkbox"> Malayalam</label>
          <label><input type="checkbox"> Norwegian</label>
          <label><input type="checkbox"> Persian</label>
          <label><input type="checkbox"> Polish</label>
          <label><input type="checkbox"> Portuguese</label>
          <label><input type="checkbox"> Punjabi</label>
          <label><input type="checkbox"> Romanian</label>
          <label><input type="checkbox"> Russian</label>
          <label><input type="checkbox"> Serbo-Croatian</label>
          <label><input type="checkbox"> Somali</label>
          <label><input type="checkbox"> Spanish</label>
          <label><input type="checkbox"> Swedish</label>
          <label><input type="checkbox"> Tamil</label>
          <label><input type="checkbox"> Turkish</label>
          <label><input type="checkbox"> Ukrainian</label>
          <label><input type="checkbox"> Urdu</label>
          <label><input type="checkbox"> Yiddish</label>
        </div>
      </div>

      <div class="header-link dropdown" id="century-slider">
        Years
        <div class="dropdown-content">
          <div class="slider-labels">
            Showing authors alive during <div id="yearValue">1800â€”2025</div>
          </div>
          <div class="range-slider">
            <div class="slider-track-container">
              <div class="slider-track"></div>
            </div>
            <input type="range" min="1800" max="2025" value="1800" class="slider" id="yearMin">
            <input type="range" min="1800" max="2025" value="2025" class="slider" id="yearMax">
          </div>

        </div>
      </div>

    </div>

    <div id="search-bar">
      <input id="search-input" type="text" placeholder="Search for authors or books" enterkeyhint="search">
      <button id="search-clear" type="button" class="search-clear" aria-label="Clear search">
        <img class="icon-x" src="icons/x.svg"></button>
    </div>

      <button class="button-secondary desktop-only" id="btnRandom">
        <span>Feeling lucky</span>
        <div class="icon-circle"><img width="16px" src="icons/shuffle.svg" alt="Shuffle icon"></div>
      </button>

      <button class="button-secondary desktop-only" id="btnAbout">
        <span>About</span>
        <div class="icon-circle"><img width="16px" src="icons/info.svg" alt="info"></div>
      </button>


  </header>

  <div id="sidebar" class="sidebar glass displaynone fade-in-up">

    <div id="sidebar-search-title-container" class="glass">
      <span id="sidebar-search-title">
        Result
      </span>
      <button onclick="toggleSidebar()" class="button-primary">
        <img id="chevron" width="16px" src="icons/chevron-up.svg"></button>
    </div>

    <div id="sidebar-search-results" class="sidebar-body"></div>

    <div id="sidebar-author-title" class="sidebar-title fade-in-right glass" onclick="backToTheResults()">
      <img class="icon-left" src="icons/chevron-left.svg" alt="back"> Back
    </div>

    <div id="sidebar-author-details" class="sidebar-author-details"></div>

  </div>

  <script>

    // Convenient names for the elements
    const logo = document.getElementById('logo');
    const filter = document.getElementById('filter');

    const searchBar = document.querySelector('#search-bar');
    const searchInput = document.getElementById('search-input');
    const clearButton = document.getElementById('search-clear');

    const searchtitle = document.getElementById('sidebar-search-title');
    const searchtitlecontainer = document.getElementById('sidebar-search-title-container');
    const searchresults = document.getElementById('sidebar-search-results');

    const sidebarauthortitle = document.getElementById('sidebar-author-title');
    const sidebarauthordetails = document.getElementById('sidebar-author-details');

    const titlechevron = document.getElementById('chevron');
    const mobileBreakpoint = 768;
    const headerLinks = document.querySelector('.header-links');

    const aboutButton = document.getElementById('aboutButton');
    const aboutContainer = document.getElementById('aboutContainer');
    const aboutCloseButton = document.getElementById('aboutCloseButton');

    const tutorialBottom = document.getElementById('tutorial-bottom');

    let tutorialComplete = false;

    // Fetch the data.geojson file with the authors data
    fetch('data.geojson').then(response => response.json()).then(data => {
      window.data = data;
    });

    // TODO: Add constants for zoom levels.

    // Function to toggle dropdown content visibility
    function toggleDropdown(dropdownId) {
      // Close all other dropdowns first
      document.querySelectorAll('.dropdown').forEach(dropdown => {
        if (dropdown.id !== dropdownId) {
          dropdown.classList.remove('header-link-active');
          dropdown.querySelector('.dropdown-content').style.display = 'none';
        }
      });

      // Toggle the clicked dropdown
      const dropdown = document.getElementById(dropdownId);
      dropdown.classList.toggle('header-link-active');
      const dropdownContent = dropdown.querySelector('.dropdown-content');
      dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
    }

    // Add click event listeners to all dropdown headers
    document.querySelectorAll('.dropdown').forEach(dropdown => {
      dropdown.addEventListener('click', (event) => {
        // Prevent the click from propagating to the document
        event.stopPropagation();
        toggleDropdown(dropdown.id);
      });
    });

    // Close all dropdowns when clicking outside
    document.addEventListener('click', () => {
      document.querySelectorAll('.dropdown').forEach(dropdown => {
        const content = dropdown.querySelector('.dropdown-content');
        content.style.display = 'none';
        dropdown.classList.remove('header-link-active');
      });
    });

    // Prevent clicks inside dropdown content from closing the dropdown
    document.querySelectorAll('.dropdown-content').forEach(content => {
      content.addEventListener('click', (event) => {
        event.stopPropagation();
      });
    });



    // Toggles the sidebar
    function toggleSidebar() {
      searchresults.style.display = searchresults.style.display === 'none' ? 'block' : 'none';
      titlechevron.style.rotate = titlechevron.style.rotate === '180deg' ? '0deg' : '180deg';
    }

    // Sets the sidebar title
    function setSidebarTitle(input) {
      searchtitle.innerHTML = input;
    }

    // Clears the sidebar
    function clearSidebar() {
      searchresults.innerHTML = "";
    }

    // Shows author details in sidebar
    function showAuthorDetails() {
      searchtitlecontainer.style.display = "none";
      searchresults.style.display = "none";

      sidebarauthortitle.style.display = "flex";
      sidebarauthordetails.style.display = "block";
    }

    // Shows results in sidebar
    function showSearchResults() {
      searchtitlecontainer.style.display = "flex";
      searchresults.style.display = "block";

      sidebarauthortitle.style.display = "none";
      sidebarauthordetails.style.display = "none";
    }

    // Shows results in sidebar and zooms out on map
    function backToTheResults() {
      if (!searchresults.style.display || searchresults.style.display === 'none') {
        map.easeTo({
          zoom: map.getZoom() - 0.5,
          duration: 500
        });
        showSearchResults();
      }
    }

    // Update the addAuthorResult function to include more details
    function addAuthorResult(properties, coordinates) {
      const {
        author_name,
        city_birth,
        city_residence,
        country,
        continent,
        year_birth,
        year_death,
        work_1,
        work_2,
        gender,
        language,
        awards,
        bio,
        list_title,
        list_bookname,
        list_copy,
        list_url
      } = properties;

      var authorDetails = `
        <div onclick="setAuthorDetails(${JSON.stringify(properties).replace(/"/g, '&quot;')}, ${coordinates[0]}, ${coordinates[1]})" 
             class="sidebar-author">
          <h3 class="author-name">${author_name}</h3>
          <h3 class="author-birth color-mid-green">${city_birth}</h3>
          <p class="text-label padtop light-gray">Author of</p>
          <p>${work_1}</p>
          <p>${work_2 || ''}</p>
        </div>`;
      searchresults.innerHTML += authorDetails;
    }

    // TODO: Remove this and the getOrdinalSuffix function, not being used anymore.
    // Function to get the century of a year
    function getCentury(year) {
      const century = Math.ceil(year / 100);
      return `${century}${getOrdinalSuffix(century)} Century`;
    }

    // Function to get the ordinal suffix of a number
    function getOrdinalSuffix(number) {
      const suffixes = ["th", "st", "nd", "rd"];
      const remainder = number % 100;
      const suffix = suffixes[(remainder - 20) % 10] || suffixes[remainder] || suffixes[0];
      return suffix;
    }

    // TODO: Remove country from this.
    // TODO: Consider not putting every value in this generator function so that search is faster.
    // Update setAuthorDetails to show more information
    function setAuthorDetails(properties, lat, long) {
      const {
        author_name,
        city_birth,
        city_residence,
        country,
        continent,
        year_birth,
        year_death,
        work_1,
        work_2,
        gender,
        language,
        awards,
        bio,
        list_title,
        list_bookname,
        list_copy,
        list_url
      } = properties;

      map.flyTo({
        center: [lat, long],
        zoom: 6
      });

      showAuthorDetails();

      // Create awards pill if awards exist
      const awardPills = awards ? awards.split(';').map(award => `<span class="pill">${award}</span>`).join('') : '';

      // Create language pill(s)
      const languagePills = language.split(';').map(lang =>
        `<span class="pill">${lang.trim()}</span>`
      ).join('');

      const featuredIn = list_title ? `
      
        <a href="${list_url}" target="_blank"><div class="card-title">${list_title}
          <img src="icons/arrow-up-right.svg" alt="arrow-up-right">
          </div>
          </a>
        <div class="card-content">
          <span class="book-title">${list_bookname}</span>
          <span>${list_copy}</span>
        </div>
      ` : '';

      sidebarauthordetails.innerHTML = `
        <h2>${author_name}</h2>
        <div class="lifetime">(${year_birth} - ${year_death ? year_death : 'Present'})</div>

        <div class="pill-container">
          <span class="pill">${continent}</span>
          <span class="pill">${gender}</span>
          ${languagePills}
          ${awardPills}
        </div>

        <p class="text-label padtop mid-gray">Author of</p>
        <p class="book">${work_1}</p>
        ${work_2 ? `<p class="book">${work_2}</p>` : ''}

        <div class="flex-equal">
          <div class="flex-1">
            <p class="text-label padtop mid-gray">Born in</p>
            <span class="color-mid-green">${city_birth}</span>
          </div>
          <div class="flex-1">
            <p class="text-label padtop mid-gray">${year_death ? 'Died in' : 'Lives in'}</p>
            <span class="color-mid-green">${city_residence}</span>
          </div>
        </div>

        ${bio ? `<p class="text-label padtop mid-gray">Bio</p><p class="bio">${bio}</p>` : ''}
        ${featuredIn}
      `;

    }

    // TODO: Obfuscate this access token somehow.
    // Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZ3lhbmwiLCJhIjoiY2swNmNoY29kMDA2ZzNjbWN4MmRvbHlmYiJ9.HJHfadzLE1cNqce2G51BEQ';

    // Initialize the map
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/gyanl/cls90czva01au01pld9fc7b5x',
      center: [2.0000, 89.0000],
      zoom: .5
    });

    // Move this function outside of map.on('load')
    async function showVisibleFeatures() {
      clearSidebar();
      const features = [];
      const displayLimit = 100;

      // Get visible features
      const visibleFeatures = map.queryRenderedFeatures({
        layers: ['clusters', 'unclustered-point']
      });

      // Handle unclustered points first (faster)
      const unclusteredFeatures = visibleFeatures
        .filter(feature => !feature.properties.cluster && feature.properties.author_name);

      // If we already have enough unclustered points, we can skip cluster processing
      if (unclusteredFeatures.length >= displayLimit) {
        showResults(unclusteredFeatures);
        return;
      }

      features.push(...unclusteredFeatures);

      // Process clusters only if we need more results
      const clusterPromises = visibleFeatures
        .filter(feature => feature.properties.cluster)
        .map(feature => {
          return new Promise((resolve, reject) => {
            map.getSource('authors').getClusterLeaves(
              feature.properties.cluster_id,
              displayLimit, // Only request up to displayLimit
              0,
              (err, leaves) => err ? reject(err) : resolve(leaves)
            );
          });
        });

      try {
        const clusterResults = await Promise.all(clusterPromises);
        clusterResults.forEach(clusterPoints => {
          features.push(...clusterPoints);
        });

        // Deduplicate results
        const seen = new Set();
        const uniqueFeatures = features.filter(feature => {
          const authorName = feature.properties.author_name;
          if (!authorName || seen.has(authorName)) return false;
          seen.add(authorName);
          return true;
        });

        showResults(uniqueFeatures);
      } catch (error) {
        console.error('Error getting cluster data:', error);
      }

      console.log('[showVisibleFeatures] -> showResults() called, map flyTo zoom=3');
    }

    // Also move showResults function outside map.on('load')
    function showResults(features) {
      clearSidebar();
      const totalCount = features.length;
      const displayLimit = 100;

      // Track authors we've already added
      const addedAuthors = new Set();
      let displayedCount = 0;

      for (const feature of features) {
        if (displayedCount >= displayLimit) break;

        if (feature.properties?.author_name &&
          !addedAuthors.has(feature.properties.author_name)) {
          addAuthorResult(
            feature.properties,
            feature.geometry.coordinates
          );
          addedAuthors.add(feature.properties.author_name);
          displayedCount++;
        }
      }

      // Update sidebar title to show total count
      if (totalCount > 0) {
        setSidebarTitle(`${totalCount > displayLimit ? `${displayLimit}+ results` : `${totalCount} results`}`);
      } else {
        setSidebarTitle("No results found");
        searchresults.innerHTML = `
          <div class="sidebar-author">
            <h3>We couldn't find any matching books or authors in the area you are looking at. Try moving around the globe or changing your filters.</h3>
            <p>If you think they should be there, fill out this form!</p>
          </div>
        `;
      }
    }

    // Move applyFilters function outside map.on('load')
    function applyFilters() {
      const searchValue = searchInput.value.toLowerCase();
      const activeFilters = getActiveFilters();
      const minYear = parseInt(yearMin.value);
      const maxYear = parseInt(yearMax.value);

      const filteredFeatures = window.data.features.filter(f => {
        const props = f.properties;

        // Add year range filter
        const birthYear = parseInt(props.year_birth);
        const deathYear = props.year_death ? parseInt(props.year_death) : new Date().getFullYear();
        const wasAliveInRange = (
          (birthYear <= maxYear && deathYear >= minYear) // Check if author's life overlapped with selected range
        );

        // Existing filter checks
        const matchesSearch = searchValue.length <= 1 ||
          props.author_name.toLowerCase().includes(searchValue) ||
          props.work_1.toLowerCase().includes(searchValue) ||
          (props.work_2 && props.work_2.toLowerCase().includes(searchValue)) ||
          props.city_birth.toLowerCase().includes(searchValue) ||
          props.city_residence.toLowerCase().includes(searchValue);

        const matchesGender = activeFilters.gender.length === 0 ||
          activeFilters.gender.includes(props.gender.toLowerCase());
        const matchesContinent = activeFilters.continent.length === 0 ||
          activeFilters.continent.includes(props.continent);
        const matchesLanguage = activeFilters.language.length === 0 ||
          (props.language && props.language.split(';').some(lang =>
            activeFilters.language.includes(lang.trim())));
        const matchesAwards = activeFilters.awards.length === 0 ||
          (props.awards && props.awards.split(';').some(award =>
            activeFilters.awards.includes(award.trim())));

        // Include year range in final check
        return matchesSearch && matchesGender && matchesContinent &&
          matchesLanguage && matchesAwards && wasAliveInRange;
      });

      // Create a fresh GeoJSON with filtered features
      const newData = {
        ...window.data,
        features: filteredFeatures
      };

      // Update the map source with filtered data
      map.getSource('authors').setData(newData);

      // Update sidebar with the newly filtered features
      showResults(filteredFeatures);
      backToTheResults();
    }

    // Also move getActiveFilters outside map.on('load')
    function getActiveFilters() {
      const filters = {
        gender: [],
        continent: [],
        language: [],
        awards: []
      };

      // Collect checked values using label text instead of IDs
      document.querySelectorAll('#gender-dropdown input:checked').forEach(checkbox => {
        filters.gender.push(checkbox.closest('label').textContent.trim().toLowerCase());
      });

      document.querySelectorAll('#continent-dropdown input:checked').forEach(checkbox => {
        filters.continent.push(checkbox.closest('label').textContent.trim());
      });

      document.querySelectorAll('#language-dropdown input:checked').forEach(checkbox => {
        filters.language.push(checkbox.closest('label').textContent.trim());
      });

      document.querySelectorAll('#awards-dropdown input:checked').forEach(checkbox => {
        filters.awards.push(checkbox.closest('label').textContent.trim());
      });

      return filters;
    }

    // Add this after map initialization
    map.on('load', function () {


      // If the user clicks intro buttom, start the experience
      document.getElementById('introButton').addEventListener('click', startExperience);

      // Start the experience by animating out the tutorial parts
      function startExperience(lat, long) {
        clearSidebar(); //so that the sidebar doesn't show the no results message
        tutorialComplete = true;
        introText.classList.replace("header-fade-in-up", "goAwayTop");
        tutorialBottom.classList.replace("header-fade-in-down", "goAwayBottom");
        aboutButton.style.display = 'none';
        // If lat and long are provided, use them. Otherwise use default coordinates
        const targetCoords = (lat && long)
          ? [long, lat]
          : [78.0000, 29.0000];

        // Use easeTo for default case, flyTo for specific coordinates
        if (lat && long) {
          map.flyTo({
            center: targetCoords,
            zoom: 4,
            duration: 1600
          });
        } else {
          map.easeTo({
            center: targetCoords,
            zoom: 4,
            duration: 1600
          });
        }

        // Wait some time and then show the sidebar and remove the intro button and text
        setTimeout(() => {
          document.getElementById('header').classList.remove('displaynone');
          document.getElementById('sidebar').classList.remove('displaynone');
          introText.style.display = 'none';
          tutorialBottom.style.display = 'none';
        }, 900);
      }

      // Rest of your existing map.on('load') code...
      map.addSource('authors', {
        type: 'geojson',
        data: 'data.geojson', // Path to GeoJSON file
        cluster: true,
        clusterMaxZoom: 14, // Max zoom to cluster points on
        clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)
      });

      // Use Mapbox GL JS's 'addLayer' function to add the points to the map.
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'authors',
        filter: ['has', 'point_count'],
        //Probably don't need this actually
        paint: {
          'circle-color': '#67FAAF',
          //Step function to set radius of unclustered circles
          'circle-radius': [
            'step',
            ['get', 'point_count'],
            15,
            10,
            20,
            20,
            30,
            30,
            40
          ]
        }
      });

      //Clustered circles
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'authors',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
          'text-size': 16,
        }
      });

      //Unclustered Points
      map.addLayer({
        id: 'unclustered-point',
        type: 'circle',
        source: 'authors',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': '#67FAAF',
          'circle-radius': 10,
        }
      });

      // Clicking on a point displays the author details in the sidebar
      map.on('click', 'unclustered-point', function (e) {

        if (!tutorialComplete) {
          startExperience(e.lngLat.lat, e.lngLat.lng);
          return;
        }

        var coordinates = e.features[0].geometry.coordinates.slice();
        var properties = e.features[0].properties;

        setSidebarTitle("1 result");
        clearSidebar();
        addAuthorResult(properties, coordinates);
        showSearchResults();

        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }
      });

      // Clicking on a cluster displays all points in cluster in sidebar
      map.on('click', 'clusters', function (e) {
        if (!tutorialComplete) {
          startExperience(e.lngLat.lat, e.lngLat.lng);
        }

        var features = map.queryRenderedFeatures(e.point, {
          layers: ['clusters']
        });
        var clusterId = features[0].properties.cluster_id;
        map.getSource('authors').getClusterLeaves(clusterId, 103, 0, function (err, leaves) {
          if (err) {
            return console.error('Error getting leaves of cluster: ', err);
          }
          clearSidebar();
          setSidebarTitle(leaves.length + " results");
          leaves.forEach(function (leaf) {
            addAuthorResult(
              leaf.properties,
              leaf.geometry.coordinates
            );
          });
        });
        showSearchResults();
      });

      // Debounce helper function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Debounced function to update results when any filter changes
      const updateFilteredResults = debounce(() => {
        clearSidebar();
        backToTheResults();
        applyFilters();
      }, 150);

      // Set up event listeners
      searchInput.addEventListener('input', updateFilteredResults);

      document.querySelectorAll('.dropdown input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          applyFilters();

          // Update the count badge
          const dropdownId = checkbox.closest('.dropdown').id;
          updateDropdownCount(dropdownId);
        });
      });


      // Update event listeners
      document.getElementById('search-bar').addEventListener('input', updateFilteredResults);
      map.on('moveend', debounce(showVisibleFeatures, 100));
      map.on('zoomend', debounce(showVisibleFeatures, 100));

      // Initial load
      showVisibleFeatures();

      clearButton.addEventListener('click', () => {
        // Clear the search box
        searchInput.value = '';
        searchInput.blur();

        // Reapply filters to update the map with filtered data
        applyFilters();
        backToTheResults();

        // Handle display logic
        if (window.innerWidth >= mobileBreakpoint) {
          logo.style.display = 'block';
          filter.style.display = 'block';
          clearButton.style.display = 'none';
        } else {
          logo.style.display = '';
          filter.style.display = '';
          clearButton.style.display = 'block';
        }

      });

      aboutButton.addEventListener('click', () => {
        const isHidden = aboutContainer.classList.contains('displaynone');
        aboutContainer.classList.toggle('displaynone');
        
        if (isHidden) {
          // Only add the document listener when opening the container
          document.addEventListener('click', handleOutsideClick);
        } else {
          // Remove the listener when closing the container
          document.removeEventListener('click', handleOutsideClick);
        }
      });

      aboutCloseButton.addEventListener('click', () => {
        aboutContainer.classList.add('displaynone');
      });
    });



    // Fly to a random filtered location on the map when feeling lucky button is clicked
    document.getElementById('btnRandom').addEventListener('click', () => {
      // Get currently filtered features based on active filters
      const searchValue = searchInput.value.toLowerCase();
      const activeFilters = getActiveFilters();
      const minYear = parseInt(yearMin.value);
      const maxYear = parseInt(yearMax.value);

      const filteredFeatures = window.data.features.filter(f => {
        const props = f.properties;

        // Add year range filter
        const birthYear = parseInt(props.year_birth);
        const deathYear = props.year_death ? parseInt(props.year_death) : new Date().getFullYear();
        const wasAliveInRange = (
          (birthYear <= maxYear && deathYear >= minYear) // Check if author's life overlapped with selected range
        );

        // Existing filter checks
        const matchesSearch = searchValue.length <= 1 ||
          props.author_name.toLowerCase().includes(searchValue) ||
          props.work_1.toLowerCase().includes(searchValue) ||
          (props.work_2 && props.work_2.toLowerCase().includes(searchValue)) ||
          props.city_birth.toLowerCase().includes(searchValue) ||
          props.city_residence.toLowerCase().includes(searchValue);

        const matchesGender = activeFilters.gender.length === 0 ||
          activeFilters.gender.includes(props.gender.toLowerCase());
        const matchesContinent = activeFilters.continent.length === 0 ||
          activeFilters.continent.includes(props.continent);
        const matchesLanguage = activeFilters.language.length === 0 ||
          (props.language && props.language.split(';').some(lang =>
            activeFilters.language.includes(lang.trim())));
        const matchesAwards = activeFilters.awards.length === 0 ||
          (props.awards && props.awards.split(';').some(award =>
            activeFilters.awards.includes(award.trim())));

        return matchesSearch && matchesGender && matchesContinent &&
          matchesLanguage && matchesAwards && wasAliveInRange;
      });

      if (filteredFeatures.length === 0) {
        console.log('No filtered features found');
        return;
      }

      // Select random feature from filtered ones
      const randomFeature = filteredFeatures[
        Math.floor(Math.random() * filteredFeatures.length)
      ];

      if (randomFeature && randomFeature.geometry) {
        // Clear author details first
        sidebar.style.display = 'none';

        // Create one-time event listener for moveend
        const onMoveEnd = () => {
          setAuthorDetails(
            randomFeature.properties,
            randomFeature.geometry.coordinates[0],
            randomFeature.geometry.coordinates[1]
          );
          sidebar.style.display = 'block';
          // Remove the listener after it fires once
          map.off('moveend', onMoveEnd);
        };

        // Add the listener
        map.on('moveend', onMoveEnd);

        // Start the animation
        map.flyTo({
          center: randomFeature.geometry.coordinates,
          zoom: 6
        });
      }
    });

    // Function to update the count badge for a dropdown
    function updateDropdownCount(dropdownId) {
      const dropdown = document.getElementById(dropdownId);
      const checkedBoxes = dropdown.querySelectorAll('input[type="checkbox"]:checked').length;

      if (checkedBoxes > 0) {
        dropdown.setAttribute('data-count', checkedBoxes);
        dropdown.classList.add('has-count');
      } else {
        dropdown.removeAttribute('data-count');
        dropdown.classList.remove('has-count');
      }
    }

    // Handling mobile dropdowns differently
    function setupMobileDropdowns() {
      if (window.innerWidth <= 768) {
        // Close dropdown when clicking outside
        document.addEventListener('click', (event) => {
          if (!event.target.closest('.dropdown')) {
            document.querySelectorAll('.dropdown-content').forEach(content => {
              content.style.display = 'none';
            });
            document.querySelectorAll('.dropdown').forEach(dropdown => {
              dropdown.classList.remove('header-link-active');
            });
          }
        });

        // Prevent body scroll when dropdown is open
        document.querySelectorAll('.dropdown').forEach(dropdown => {
          dropdown.addEventListener('click', () => {
            if (dropdown.classList.contains('header-link-active')) {
              document.body.style.overflow = 'hidden';
            } else {
              document.body.style.overflow = '';
            }
          });
        });
      }
    }

    // Call this function when the page loads and on resize
    window.addEventListener('load', setupMobileDropdowns);
    window.addEventListener('resize', setupMobileDropdowns);



    document.addEventListener('DOMContentLoaded', () => {

      // Show/hide clear button based on input content
      searchInput.addEventListener('input', () => {
        if (window.innerWidth >= mobileBreakpoint) {
          clearButton.style.display = searchInput.value ? 'block' : 'none';
        }
      });

      // Initialize clear button visibility
      if (window.innerWidth >= mobileBreakpoint) {
        clearButton.style.display = searchInput.value ? 'block' : 'none';
      }

      // When search bar is clicked, hide logo and filter on mobile
      searchBar.addEventListener('click', () => {
        if (window.innerWidth <= mobileBreakpoint) {
          logo.style.display = 'none';
          filter.style.display = 'none';
          clearButton.style.display = 'block';
        }
      });



      filter.addEventListener('click', showFilters);

      function showFilters() {
        console.log('%c[showFilters] Called', 'color: #0af');
        console.log(
          '[showFilters]',
          'headerLinks.style.display before:', `"${headerLinks.style.display}"`,
          'logo.style.display before:', `"${logo.style.display}"`
        );

        headerLinks.style.display = 'flex';
        logo.style.display = 'none';

        console.log(
          '[showFilters]',
          'headerLinks.style.display after:', `"${headerLinks.style.display}"`,
          'logo.style.display after:', `"${logo.style.display}"`
        );
      }

    });

    // Add these constants with your other ones at the top
    const yearMin = document.getElementById('yearMin');
    const yearMax = document.getElementById('yearMax');
    const yearValue = document.getElementById('yearValue');

    // Add this debounce function with your other utility functions
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Modify the setupYearRangeSlider function
    function setupYearRangeSlider() {
      const debouncedApplyFilters = debounce(applyFilters, 250);
      const track = document.querySelector('.slider-track');

      function updateTrack() {
        const minVal = parseInt(yearMin.value);
        const maxVal = parseInt(yearMax.value);
        const minPercent = ((minVal - 1800) / (2025 - 1800)) * 100;
        const maxPercent = ((maxVal - 1800) / (2025 - 1800)) * 100;

        track.style.setProperty('--start-percent', `${minPercent}%`);
        track.style.setProperty('--end-percent', `${maxPercent}%`);
      }

      yearMin.addEventListener('input', (e) => {
        const minVal = parseInt(yearMin.value);
        const maxVal = parseInt(yearMax.value);

        if (minVal > maxVal) {
          yearMin.value = maxVal;
          return;
        }

        yearValue.textContent = `${minVal}â€”${maxVal}`;
        updateTrack();
        debouncedApplyFilters();
      });

      yearMax.addEventListener('input', (e) => {
        const minVal = parseInt(yearMin.value);
        const maxVal = parseInt(yearMax.value);

        if (maxVal < minVal) {
          yearMax.value = minVal;
          return;
        }

        yearValue.textContent = `${minVal}â€”${maxVal}`;
        updateTrack();
        debouncedApplyFilters();
      });

      // Initialize track
      updateTrack();
    }

    // Call setupYearRangeSlider when the page loads
    document.addEventListener('DOMContentLoaded', setupYearRangeSlider);

    // Add this after your existing checkbox event listeners
    document.querySelectorAll('#continent-dropdown input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        if (e.target.checked) {
          // Only fly to location if checkbox is being checked
          const continent = e.target.closest('label').textContent.trim();
          const continentCoordinates = {
            'Africa': [17.5707, 3.8690],
            'Asia': [100.6197, 34.0479],
            'Australia': [133.7751, -25.2744],
            'Europe': [15.2551, 54.5260],
            'North America': [-105.2551, 54.5260],
            'Latin America': [-58.9300, -23.4425]
          };

          if (continentCoordinates[continent]) {
            map.flyTo({
              center: continentCoordinates[continent],
              zoom: 2.5,
              duration: 1500
            });
          }
        }

        // Apply filters regardless of checked state
        applyFilters();
        updateDropdownCount('continent-dropdown');
      });
    });

    // Add single event listener for clicks outside aboutContainer
    const handleOutsideClick = (event) => {
      if (!event.target.closest('#aboutContainer') && !event.target.closest('#aboutButton')) {
        aboutContainer.classList.add('displaynone');
      }
    };

  </script>

</body>

</html>